[[Command_Line_Processor]]
The COMMAND LINE PROCESSOR (CLEP) is a user application programming
interface for several platforms including Windows, Unix and z/OS that
simplifies and standardizes parameter string processing.

The CLEP provides two separate functions:

 * COMMAND LINE PARSER (CLP)   - Compiles a parameter string from a command to a data structure
 * COMMAND LINE EXECUTOR (CLE) - Supporting execution of different commands with parameter strings

The COMMAND LINE EXECUTOR provides a list of commands and some
built-in functions, please use 'MANPAGE', 'HELP' and 'SYNTAX' to get
extensive information about these capabilities.

Additionally the build-in function 'GENDOCU' can generate a complete or
a part of the user manual.

To read the parameter of a command, a compiler (CLP) is applied. To see
the regular expressions (lexems) and the corresponding grammar, please
use the built-in functions 'LEXEM' and 'GRAMMAR'.

The return/condition/exit codes of the executable and the reason codes
of the different commands can be reviewed with the built-in function
'ERRORS'.
See <<appendix-Returncodes,'appendix-Returncodes'>> and, if available, 
<<appendix-Reasoncodes, appendix-Reasoncodes>> 
for the meaning of the used return and reason codes.

The CLE uses an owner management in order to separate the settings for
different clients and a property management for each command. If
problems occur, a trace might be activated.

For each command execution the owner and environment variables can be
defined in the configuration file.

The default trace file is 'stdout'. If the trace is activated before a
trace file is defined, the trace will be printed on the screen.

Last but not least it is possible to view the license, version and other
information about the program.

This is the ${__BUILD__} build version of the FLAMCLEP.

COMMAND LINE CONSIDERATIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The command line parser supports abbreviation of key words depending on
the unique first characters. This is only useful if you work in dialog.
If the command is specified in a persistent way (e.g. in a script) writing
the complete keyword is recommended, to ensure that the script must not be
changed to work with a later version of the program.

The same is valid for the required string support. The CLP supports
strings without enclosing. These strings depend on the keywords used
in a name space. If new key words are added in future version, the string
could cause errors and must be enclosed. Concerning this it is
recommended to enclose strings if the command is defined in a script.

The last item which could result in a damaged command syntax after a
program update is the use of implicit array definitions after an
assignment, because the end of such an array might change, for
example if an array of numbers defined an a switch is the end. In a
new version such a switch could be a number with a default value, if only
the keyword is defined. In this case the defined number referenced by this
keyword is then part of the number array and the parameter is lost.
Concerning this it is recommended to use enclosed array definitions.

All these capabilities are implemented to be compatible with several
existing command lines syntaxes and to limit the effort to port old
commands or to simplify the interactive use. But in certain cases,
the command interpretation could fail, if not the unique variant of
keywords, strings and arrays are used.

USED ENVIRONMENT VARIABLES
~~~~~~~~~~~~~~~~~~~~~~~~~~

 * LANG    - to determine the CCSID on EBCDIC systems
 * HOME    - to determine the home directory on UNIX/WIN
 * USER    - to determine the current user id on UNIX/WIN
 * ENVID   - for the current environment qualifier (D/T/P) if key label template mapping used (default is 'T')
 * OWNERID - used for current owner if not already defined
 * CLP_NOW - The current point in time used for predefined constants (0tYYYY/MM/DD.HH:MM:SS)
 * CLP_STRING_CCSID - CCSID used for interpretation of critical punctuation character on EBCDIC systems (default is taken from LANG)
 * CLP_DEFAULT_DCB - The default record format and record length in C file mode format (default is 'recfm=VB, lrecl=516' only for z/OS)
 * &{PGM}_CONFIG_FILE - the configuration filename (default is '$HOME/.&{pgm}.config' on UNIX/WIN or '&SYSUID..&{PGM}.CONFIG' on mainframes)
 * &{PGM}_DEFAULT_OWNER_ID - the default owner ID (default is '&{oWn}')
 * owner_&{PGM}_command_PROPERTY_FILENAME - To override default property file names
 * path_argument - to override the hard coded default property value
 
Environment variables can be set from the system or in the program
configuration file with the build-in function 'SETENV'. Particularly on
mainframe systems the configuration file is an easy way to define
environment variables. Additionally on host systems the DD name STDENV 
and with lower priority the data set name '&SYSUID..STDENV' is
supported. On the other architectures the file '.stdenv' in the
working or with lower priority in the home directory can be used to
define environment variables for FLAM utility, subsystems and subprogram
interfaces.

The STDENV files allows to define the &{PGM}_CONFIG_FILE,
&{PGM}_DEFAULT_OWNER_ID, LANG and other environment variables
in JCL:

Below a you can find a sample with a z/OS DD name allocation.
-----------------------------------------------------------------------
 //STDENV   DD *
 &{PGM}_CONFIG_FILE=GLOBAL.&{PGM}.CONFIG
 LANG=de_DE.IBM-1141
 HOME=/u/hugo
 USER=hugo
 ENVID=T
 /*
-----------------------------------------------------------------------
The definition of the LANG variable outside of the program configuration
file is recommended, so that the system character set is defined in each
situation. The program configuration file name is used as is, there are
no replacements (<USER>) possible, because it is used in front of
establishment of the environment it self.

Often it will be useful to have a dedicated environment per user on
mainframes. In such a case it makes sense to define the environment in
a dedicated file for each user.

-----------------------------------------------------------------------
 //STDENV   DD DSN=USER.ENVIR(&SYSUID.), DSP=SHR
-----------------------------------------------------------------------

Since z/OSv2r1 you can also used exported JCL symbols like environment
variables. The exported JCL symbols have lower priority then the same
environment variable. The service CEEGTJS is called dynamically and the
language environment must be in the STEPLIB concatenation to use it.
Additional all z/OS system symbols can be used in the in the string
replacement (<&LDAY>). The environment variable have the highest
priority, followed by the exported JCL symbols. The lowest priority have
system symbols. If the variable name not found, then no replacement are
done and the angle bracket keep still in place.

------------------------------------------------------------------------
 //E0       EXPORT SYMLIST=*
 //S1       SET    BLKSIZE=27886
 //S3       SET    LRECL=128
------------------------------------------------------------------------

Beside all the environment variables managed by CLE it is possible to
set all properties as environment variables to override the hard coded
default values with CLP. If a property is defined as environment variable
and in a property file, then the value in the property file overrides the
setting in the environment. The environment variable name for each
property is build by the rules below:

 * convert all letters to upper case
 * replace all dots (`.`) by underline (`_`)

To get a list and help for all properties please use the built-in
function 'GENPROP' to generate property files. The properties can be
defined per owner, per program and general. The owner specific
definition overrides the program specific definition and the program
specific definition overrides the general definition. Examples:

-----------------------------------------------------------------------
CONV_READ_TEXT_ENL2LF=OFF #in general the 0x15 to 0x25 conversion is off#
HUGO_FLCL_CONV_READ_TEXT_ENL2LF=ON # for owner 'hugo' the conversion is on#
-----------------------------------------------------------------------

The value string behind the sign (including the comment) will be used as
supplement for the command line processor. Aliases are not supported in
this case. You can only define properties for the main argument. If a
string must be enclosed with apostrophe, please don't use double
quotation marks, because these are used in addition if a new property
file is build based on the environment settings.

-----------------------------------------------------------------------
FLCL_ICNV_FROM='IBM-1141'         # this is the best solution 
FLCL_ICNV_TO=UTF-8                # "UTF-8" could result in errors
-----------------------------------------------------------------------

See <<Properties,Properties>> for the current property file content.

For z/OS the default record format and record length for non-existing
output files is 'recfm=VB, lrecl=512'. The file open function try first
to open an existing file with 'recfm=*' to overwrite (DISP=OLD) and if
this fails the 'recfm=*' in the file mode string is replaced with
'recfm=VB, lrecl=512' and an open to write a new file (DISP=NEW) will be
done. The environment variable CLP_DEFAULT_DCB can be used to change this
file mode string. See 'Keyword Parameters for File Mode' for fopen() in
'z/OS XL C/C++ Runtime Library Reference' for more information and for
the correct syntax. Beside the 'recfm' with a valid record format (not
'*' or '+') and the 'lrecl' you can also define the 'space' parameter.
All other file mode parameter are managed by CLP.

ENVIRONMENT VARIABLE MAPPING
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each value enclosed with angle brackets (`<>`) are replaced with the
corresponding environment variable (`<LANG>`). This feature is available
at each starting point of a lexem and inside of a normal string.

If the environment variable not defined the replacements below are still
possible:
 * <SYSUID> - Current user id in upper case
 * <USER>   - Current user id (case sensitive)
 * <CUSER>  - Current user id in upper case == <SYSUID>
 * <Cuser>  - Current user id in title case
 * <cuser>  - Current user id in lower case
 * <HOME>   - Replaces with the users data directory, if this not
               available the replacements below are done:
 ** On UNIX with /home/<USER>
 ** On USS with /u/<USER>
 ** On ZOS with <SYSUID>

[[CLEP.FNMAPPING]]
FILENAME MAPPING
~~~~~~~~~~~~~~~~

All filenames used by CLEP are additionally mapped based on the rules
below:

 * The tilde character (`~`) is replaced with the string "<HOME>"
 * DD names on mainframes must be prefixed with "DD:"
 * Data set names on mainframes are always full qualified
 * Path names on mainframes must contain a least one slash (`/`)
 * Data set names on USS must start with //
 ** Full qualified names with HLQ must enclose in apostrophes ("//''")
 ** If apostrophes are not used the SYSUID is prefixed as HLQ
 * Normal file names on other platforms could be relative
 
*ATTENTION:* If a requested environment variable is not defined, the
replacement is done with the empty string. This can result in
unexpected behavior.

To use a "<" or "~" as a part of a filename the character must be
specified twice.

Beside this rules the replacement technologies of your shell can be used,
but on some platforms $HOME, $USER or something similar might not
be available, for such cases the possibilities above are implemented.

This file name mapping is provided by the library CLEPUTL and should
also be used for file names managed by the commands supported with this
program.

KEY LABEL NAME MAPPING
~~~~~~~~~~~~~~~~~~~~~~

The key label name mapping works like the file name mapping, but you can
additional use `^` to replace it with the OWNERID (`^=<ONWERID>`), `!`
to replace it with the environment identifier (`!=<ENVID>`) and `~` is
only replaced with login user id. If the environment ID not defined then
`T` for test is used by default.

SPECIAL EBCDIC CODE PAGE SUPPORT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To interpret commands correctly the punctuation characters below are on
different code points depending on the EBCDIC CCSID used to enter these
values.

------------------------------------------------------------------------
   CRITICAL PUNCTUATION CHARACTERS: ! $ # @ [ \\ ] ^ ` { | } ~ 
------------------------------------------------------------------------

These critical characters are interpreted normally dependent on the
environment variable LANG. If the environment variable LANG is not
defined then the default CCSID IBM1047 (Open Systems Latin-1) is used.
Below is the current list of supported CCSIDs on EBCDIC systems.

------------------------------------------------------------------------
   SUPPORTED EBCDIC CODE PAGES FOR COMMAND ENTRY:
      "IBM-1140","IBM-1141","IBM-1142","IBM-1143",
      "IBM-1144","IBM-1145","IBM-1146","IBM-1147",
      "IBM-1148","IBM-1149","IBM-1153","IBM-1154",
      "IBM-1156","IBM-1122","IBM-1047","IBM-924",
      "IBM-500","IBM-273","IBM-037","IBM-875","IBM-424",
      "IBM-277","IBM-278","IBM-280","IBM-284","IBM-285",
      "IBM-297","IBM-871","IBM-870","IBM-1025","IBM-1112",
      "IBM-1157"
------------------------------------------------------------------------

You can define the code page explicitly (LANG=de_DE.IBM-1141) or only
the language code (LANG=de_DE, LANG=C). If only the language code
defined then the CCSID is derived from the language code (DE=IBM-1141,
US=IBM-1140, C=IBM-1047, ...).

If possible, these critical characters are also converted for print
outs. At output it is not possible to convert anything correctly,
because some strings for print out are coming from other sources (like
system messages and others). Only all known literals are converted, for
unknown variables such a conversion is not possible and CLEP expects that
such strings are encoded in the correct system code page, but there is no
guaranty for this.

To be independent of the environment escaping of the CLP strings is
possible for the critical punctuation characters on EBCDIC systems.
See list below:

------------------------------------------------------------------------
   ! = &EXC;   - Exclamation mark
   $ = &DLR;   - Dollar sign
   # = &HSH;   - Hashtag (number sign)
   @ = &ATS;   - At sign
   [ = &SBO;   - Square bracket open
   \\ = &BSL;   - Backslash
   ] = &SBC;   - Square bracket close
   ^ = &CRT;   - Caret (circumflex)
   ` = &GRV;   - Grave accent
   { = &CBO;   - Curly bracket open
   | = &VBR;   - Vertical bar
   } = &CBC;   - Curly bracket close
   ~ = &TLD;   - Tilde
------------------------------------------------------------------------

A escape sequence starts with the ampersand (&) followed be 3 character
(not case sensitive) and is terminated with semicolon (;). With an X and
2 hexadecimal digit the definition of a binary byte value are possible.
If such a sequence in the string required then the ampersand must be
typed twice (&&). To mark a part or the of whole string in a certain
CCSID the escape sequence must contain 1 to 6 digits. Few samples can
be found below:

------------------------------------------------------------------------
   &1047; all in 1047 &0; reset to system code page &1140; no in 1140
------------------------------------------------------------------------

At the beginning the system code page is active except the environment
variable CLP_STRING_CCSID is defined. The defined CCSID is valid till
the next CCSID definition. An unsupported CCSID (0) can be used to
restore the interpretation to the system code page.

*ATTENTION:* This is no character set conversion, only the UNICODE code
points 0-127 which are on different code points in the different EBCDIC
code pages are replaced. All other higher code points (e.g. German
Umlauts ('ä','ü','ö')) are not touched.

The partial CCSID conversion are mainly useful for application
programming interfaces. At compile time the CCSID for literals must be
defined. This CCSID could be differ from the system CCSID (local
character set) of variable parameter. In such a case a application can
mark the literal part in the CCSID used for literals at compile time,
and the variable part could be conform to the CCSID defined over the
LANG variable. See the C example below:

------------------------------------------------------------------------
   snprintf(acCmd,sizeof(acCmd),"&1047;get.file='&0;%s&1047'",pcFilename);
------------------------------------------------------------------------

C-Code are normally in 1047 and if no literal conversion defined then
the literals also in 1047. The file name is a parameter in local
character set. In Cobol the default code page for literals is 1140.
To define the CCSID for CLP strings from outside, the environment
variable CLP_STRING_CCSID can be defined. This is useful if an
application cannot recompile with the correct code page for the
literals.

On ASCII/UTF-8 platforms a miss-interpretation of punctuation characters
smaller than 128 is not possible. On such platforms the LANG variable is
not used for command interpretation or printouts. The escape and CCSID
sequences are supported but have no effect on these platforms. This
helps to develop platform independent code for CLP strings.
